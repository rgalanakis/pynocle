#!/usr/bin/env python
"""
pynocle is a module for reporting of code metrics and other inspection/reporting features.

It is meant to be used as a very simple API, usually as part of the the testing/build process.  Simply
create a new Monocle object with the directories and files you want to analyze
(along with coverage data if you have it), and call generate_all.
"""

__author__ = "Rob Galanakis"
__copyright__ = "Copyright 2011, Rob Galanakis"
__version__ = "0.1.23"
__email__ = "rob.galanakis@gmail.com"
__status__ = "Pre-Alpha"

import pynocle.utils as utils

try:
    import coverage
except ImportError as exc:
    coverage = utils.MissingDependencyError(repr(exc))
    pass
import os
import shutil

import _pynoclecover
import cyclcompl
import depgraph
import sloc

def _check_coverage():
    """If coverage is a MissingDependencyError (as opposed to a module), raise.  We do this so we don't fail if we
    try to import coverage.
    """
    if type(coverage) == utils.MissingDependencyError:
        raise coverage

def run_with_coverage(func, **coveragekwargs):
    """Runs and returns the result of func (a parameterless function).  coveragekwargs are used to create a
    coverage.coverage instance.
    """
    _check_coverage()
    return _pynoclecover.run_with_coverage(func, **coveragekwargs)


def ensure_clean_output(outputdir, _ran=0):
    """rmtree and makedirs outputdir to ensure a clean output directory.

    outputdir: The folder to create.
    _ran: For internal use only.
    """
    # There is a potential race condition where rmtree seems to succeed
    # and makedirs fails so #the directory doesn't exist.
    # So for the time being, if makedirs fails, we re-invoke the function
    # 3 times.  I have observed this condition many times in the wild- I
    # don't want to believe it exists, but it does.
    try:
        shutil.rmtree(outputdir)
    except WindowsError:
        pass
    if os.path.exists(outputdir):
        raise IOError('%s was not deleted.' % outputdir)
    try:
        os.makedirs(outputdir)
    except WindowsError:
        if _ran < 3:
            ensure_clean_output(outputdir, _ran=_ran + 1)
        if not os.path.isdir(outputdir):
            raise


def _create_dependency_group(codefilenames, dependencygroup):
    """If dependencygroup is provided, returns that, otherwise generates a new DependencyGroup from
    codefilenames.
    """
    if not dependencygroup:
        depb = depgraph.DepBuilder(codefilenames)
        dependencygroup = depgraph.DependencyGroup(depb.dependencies, depb.failed)
    return dependencygroup


def _generate_html_jump_str(htmlfilename, paths):
    """Generates the html contents for the jump page."""
    htmltemplate = '\n'.join(
        ['<html>',
        '  <head>',
        '    <title>Project Metrics, generated by pynocle.</title>',
        '  </head>',
        '  <body>',
        '%s',
        '  </body>',
        '</html>'])
    row = '      <a href="{0}">{0}</a>'
    absdir = os.path.dirname(os.path.abspath(htmlfilename)) + os.sep
    def hrefpath(p):
        absp = os.path.abspath(p)
        relp = absp.replace(absdir, '')
        return relp
    lines = [row.format(hrefpath(p)) for p in paths]
    return htmltemplate % '\n      <br />\n'.join(lines)

def generate_html_jump(filename, *paths):
    """Generates an html file at filename that contains links to all items in paths.

    filename: Filename of the resultant file.
    paths: Paths to all files the resultant file should display links to.
    """
    with open(filename, 'w') as f:
        f.write(_generate_html_jump_str(filename, sorted(paths)))

class Monocle(object):
    """Entry point for all metrics generation.

    outputdir: Directory to write reports.
    rootdir: The root directory of the python files to search.
    coveragedata: A coverage.coverage instance.  You can get this from running coverage, or loading a coverage data
        file.
    debug: If True, fail early instead of failing after all report generation.

    *_filename/*_dir: File/directory names to output metrics to.  IReportFormatter instances will be chosen
    per-report based on the filename extension.  In order to override this mapping or provide your own formatter,
    modify the *_formatter_registry objects in each module.  Better override support will be added in the future.
    """
    def __init__(self, outputdir='output',
                 rootdir=None,
                 coveragedata=None,
                 coverhtml_dir='report_covhtml',
                 coverreport_filename='report_coverage.txt',
                 cyclcompl_filename='report_cyclcompl.html',
                 sloc_filename='report_sloc.html',
                 depgraph_filename='depgraph.png',
                 coupling_filename='report_coupling.html',
                 couplingrank_filename='report_couplingrank.html',
                 htmljump_filename='index.html',
                 debug=False):
        if not isinstance(rootdir, basestring):
            raise ValueError, 'Monocle only supports one root directory right now.'
        rootdir = os.path.abspath(rootdir or os.getcwd())
        self.filenames = utils.find_all([rootdir])

        self.outputdir = outputdir
        self.coveragedata = coveragedata
        self.debug = debug

        join = lambda x: os.path.join(self.outputdir, x)
        self.coverhtml_dir = join(coverhtml_dir)
        self.coverreport_filename = join(coverreport_filename)
        self.cyclcompl_filename = join(cyclcompl_filename)
        self.sloc_filename = join(sloc_filename)
        self.depgraph_filename = join(depgraph_filename)
        self.coupling_filename = join(coupling_filename)
        self.couplingrank_filename = join(couplingrank_filename)
        self.htmljump_filename = join(htmljump_filename)

        kwargs = {'leading_path': rootdir}
        def gext(s):
            return os.path.splitext(s)[1]
        self.cyclcompl_fmtfactory = cyclcompl.formatter_registry.GetFormatterFactory(gext(self.cyclcompl_filename),
                                                                                     **kwargs)
        self.sloc_fmtfactory = sloc.formatter_registry.GetFormatterFactory(gext(self.sloc_filename), **kwargs)
        self.coupling_fmtfactory = depgraph.coupling_formatter_registry.GetFormatterFactory(
            gext(self.coupling_filename), **kwargs)
        self.couplingrank_fmtfactory = depgraph.couplingrank_formatter_registry.GetFormatterFactory(
            gext(self.couplingrank_filename), **kwargs)

        self.depgraph_renderfactory = lambda g: depgraph.DefaultRenderer(g, leading_path=rootdir)
        
        self._filesforjump = set()

    def ensure_clean_output(self):
        ensure_clean_output(self.outputdir)

    def generate_cover_html(self):
        """Outputs a coverage html report from cov into directory.

        cov: An instance of coverage.coverage.
        directory: The directory all the html files will be output to.  Directory must exist.
        """
        #isinstance causes scope problems so use exact type checking here.
        _check_coverage()
        self.coveragedata.html_report(directory=self.coverhtml_dir)
        self._filesforjump.add(os.path.join(self.coverhtml_dir, 'index.html'))

    def generate_cover_report(self):
        """Generates a coverage report for cov to filename."""
        #isinstance causes scope problems so use exact type checking here.
        _check_coverage()
        with open(self.coverreport_filename, 'w') as f:
            self.coveragedata.report(file=f)
        self._filesforjump.add(self.coverreport_filename)

    def generate_cyclomatic_complexity(self):
        """Generates a cyclomatic complexity report for all files in self.files, output to self.cyclcompl_filename.
        """
        ccdata, failures = cyclcompl.measure_cyclcompl(self.filenames)
        utils.write_report(self.cyclcompl_filename, (ccdata, failures), self.cyclcompl_fmtfactory)
        self._filesforjump.add(self.cyclcompl_filename)

    def generate_sloc(self):
        """Generates a Source Lines of Code report for all files in self.files, output to self.sloc_filename.
        """
        slocgrp = sloc.SlocGroup(self.filenames)
        utils.write_report(self.sloc_filename, slocgrp, self.sloc_fmtfactory)
        self._filesforjump.add(self.sloc_filename)

    def generate_dependency_graph(self, _depgrp=None):
        """Generates a dependency graph image to self.depgraph_filename for the files in self.files.  Returns an
        instance of DependencyGroup.
        """
        depgrp = _create_dependency_group(self.filenames, _depgrp)
        renderer = self.depgraph_renderfactory(depgrp)
        renderer.render(self.depgraph_filename)
        self._filesforjump.add(self.depgraph_filename)
        return depgrp

    def generate_coupling_report(self, _depgrp=None):
        """Generates a report for Afferent and Efferent Coupling between all modules in self.filenames, saved to
        self.coupling_filename.  Returns an instance of DependencyGroup.
        """
        depgrp = _create_dependency_group(self.filenames, _depgrp)
        utils.write_report(self.coupling_filename, depgrp, self.coupling_fmtfactory)
        self._filesforjump.add(self.coupling_filename)
        return depgrp

    def generate_couplingrank_report(self, _depgrp=None):
        """Generates a PageRank report for all code in self.filenames to self.couplingrank_filename.  Returns an
        instance of DependencyGroup.
        """
        depgrp = _create_dependency_group(self.filenames, _depgrp)
        utils.write_report(self.couplingrank_filename, depgrp, self.couplingrank_fmtfactory)
        self._filesforjump.add(self.couplingrank_filename)
        return depgrp

    def generate_html_jump(self):
        """Generates an html page that links to any generated reports."""
        return generate_html_jump(self.htmljump_filename, *sorted(self._filesforjump))

    def generate_all(self, cleanoutput=True):
        """Run all report generation functions.

        If coveragedata is not set, skip the coverage functions.
        If not self.debug, raises an AggregateError after all functions run if any function raises (so metrics will
            be generated for any function that succeeds).
        cleanoutput: If True, run ensure_clean_output to clear the output directory.
        """
        if cleanoutput:
            self.ensure_clean_output()
        excs = []
        def trydo(func):
            if self.debug:
                return func()
            try:
                return func()
            except Exception as exc:
                import traceback
                excs.append((exc, traceback.format_exc()))

        trydo(self.generate_sloc)
        trydo(self.generate_cyclomatic_complexity)

        if self.coveragedata:
            trydo(self.generate_cover_report)
            trydo(self.generate_cover_html)
            
        depgrp = trydo(self.generate_coupling_report)
        depgrp = trydo(lambda: self.generate_couplingrank_report(depgrp))
        depgrp = trydo(lambda: self.generate_dependency_graph(depgrp))
        trydo(self.generate_html_jump)
         #self.generate_funcinfo_report,
         #self.generate_inheritance_report,
        if excs:
            raise utils.AggregateError, excs
