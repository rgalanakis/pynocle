"""Module for reporting of code metrics and other inspection/reporting features.  The main public usage is through
monocle_chain.
"""

import coverage
import nose
import os
import shutil

import pygenie
import sloc

class NoseArgs(object):
    """Encapsulates arguments that can be send to nose.run/nose.main."""
    def __init__(self, included_dirs, with_doctest=True, verbose=False):
        self.with_doctest = with_doctest
        #self.excludedDirs = excludedDirs
        self.included_dirs = included_dirs
        self.verbose = verbose

    def to_nose_argv(self):
        """Returns a list of arguments to send to nose.run/nose.main."""
        args = []
#        if self.excludedDirs:
#            args.append('--exclude')
#            regstrs = map(lambda s: '(%s)' % s, self.excludedDirs)
#            args.append('|'.join(regstrs))
        if self.included_dirs:
            for incl in self.included_dirs:
                #args.append('--where')
                args.append(incl)
        #make sure this is last- if it's first, it seems to not work
        if self.with_doctest:
            args.append('--with-doctest')
        if self.verbose:
            args.append('--verbose')
        return args

def ensure_clean_output(outputdir):
    """rmtree's outputdir and creates a new empty directory."""
    try:
        shutil.rmtree(outputdir)
    except WindowsError:
        pass
    try:
        os.mkdir(outputdir)
    except WindowsError:
        pass

def run_nose(noseargs):
    """Invoke nose.run with noseargs and returns its result."""
    result = nose.run(argv=noseargs.to_nose_argv())
    return result

def run_with_coverage(func, filename):
    """Runs func (parameterless callable) with coverage on.  Saves coverage to filename.  Returns a tuple
    of the return value of func, and the coverage object created.
    """
    cov = coverage.coverage(data_file=filename)
    cov.erase()
    cov.start()
    result = func()
    cov.stop()
    cov.save()
    return result, cov

def generate_cover_html(cov, directory):
    """Outputs a coverage html report from cov into directory.

    cov: An instance of coverage.coverage.
    directory: The directory all the html files will be output to.
    """
    cov.html_report(directory=directory)

def generate_cover_report(cov, filename):
    """Generates a coverage report for cov to filename."""
    with open(filename, 'w') as f:
        cov.report(file=f)

def generate_cyclomatic_complexity(files_and_folders, filename, threshold=None):
    """Generates a cyclomatic complexity report based on all the files in and recursively under directories in
    files_and_folders, output to filename.

    threshold: If provided, override the amount of complexity at which data is reported.
    """
    args = ['--outfile', filename, '--complexity', '--recurs']
    if threshold is not None:
        args.extend(['--threshold', str(threshold)])
    #else: args.extend(['--threshold', '0'])
    args += list(files_and_folders)
    pygenie.main(args)

def generate_sloc(files_and_folders, filename):
    """Generates a Source Lines of Code report for files in and recursively under directories in files_and_folders,
    output to filename.
    """
    result = sloc.countall(files_and_folders)
    with open(filename, 'w') as f:
        s = sloc.SlocFormatter(result, f)
        s.print_sloc_header()
        s.print_sloc_perfile()

def _generate_html_jump_str(paths):
    """Generates the html contents for the jump page."""
    htmltemplate = '\n'.join(
        ['<html>',
        '  <head>',
        '    <title>Project Metrics, generated by pynocle.</title>',
        '  </head>',
        '  <body>',
        '%s',
        '  </body>',
        '</html>'])
    row = '      <a href="{0}">{0}</a>'
    lines = [row.format(p) for p in paths]
    return htmltemplate % '\n      <br />\n'.join(lines)

def generate_html_jump(filename, *paths):
    """Generates an html file at filename that contains links to all items in paths.

    filename: Filename of the resultant file.
    paths: Paths to all files the resultant file should display links to.
    """
    with open(filename, 'w') as f:
        f.write(_generate_html_jump_str(paths))

class Monocle(object):
    """Class that manages the filenames and default paths for the monocle methods.  Methods are the same as
    top-level module functions.
    """
    def __init__(self, outputdir='output', coveragedata_filename='.coverage', coverhtml_dir='report_covhtml',
                 coverreport_filename='report_coverage.txt', cyclcompl_filename='report_cyclcompl.txt',
                 sloc_filename='report_sloc.txt', htmljump_filename='index.html'):
        self.outputdir = outputdir
        self.coveragedata_filename = os.path.join(self.outputdir, coveragedata_filename)
        self.coverhtml_dir = os.path.join(self.outputdir, coverhtml_dir)
        self.coverreport_filename = os.path.join(self.outputdir, coverreport_filename)
        self.cyclcompl_filename = os.path.join(self.outputdir, cyclcompl_filename)
        self.sloc_filename = os.path.join(self.outputdir, sloc_filename)
        self.htmljump_filename = os.path.join(self.outputdir, htmljump_filename)

    def ensure_clean_output(self):
        return ensure_clean_output(self.outputdir)

    def run_with_coverage(self, func):
        return run_with_coverage(func, self.coveragedata_filename)

    def generate_cover_html(self, cov):
        return generate_cover_html(cov, self.coverhtml_dir)

    def generate_cover_report(self, cov):
        return generate_cover_report(cov, self.coverreport_filename)

    def generate_cyclomatic_complexity(self, files_and_folders, threshold=None):
        return generate_cyclomatic_complexity(files_and_folders, self.cyclcompl_filename, threshold=threshold)

    def generate_sloc(self, files_and_folders):
        return generate_sloc(files_and_folders, self.sloc_filename)

    def generate_html_jump(self):
        """Generates an html page that links to any generated reports."""
        covhtmlindex = os.path.join(self.coverhtml_dir, 'index.html')
        return generate_html_jump(self.htmljump_filename,
                          covhtmlindex, self.coverreport_filename, self.cyclcompl_filename, self.sloc_filename)
