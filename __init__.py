#!/usr/bin/env python
"""
pynocle is a module for reporting of code metrics and other inspection/reporting features.

It is meant to be used as a very simple API, usually as part of the the testing/build process.  Simply
create a new Monocle object with the directories and files you want to analyze
(along with coverage data if you have it), and call generate_all.
"""

__author__ = "Rob Galanakis"
__copyright__ = "Copyright 2011, Rob Galanakis"
__version__ = "0.1.23"
__email__ = "rob.galanakis@gmail.com"
__status__ = "Pre-Alpha"

import pynocle.utils as utils

try:
    import coverage
except ImportError as exc:
    coverage = utils.MissingDependencyError(repr(exc))
    pass
import os
import shutil

import _pynoclecover
import cyclcompl
import depgraph
import sloc

def _check_coverage():
    if type(coverage) == utils.MissingDependencyError:
        raise coverage

def run_with_coverage(func, **coveragekwargs):
    _check_coverage()
    return _pynoclecover.run_with_coverage(func, **coveragekwargs)

def ensure_clean_output(outputdir, _ran=False):
    """rmtree and makedirs outputdir to ensure a clean output directory.

    outputdir: The folder to create.
    _ran: For internal use only.
    """
    #There is a potential race condition where rmtree seems to succeed and makedirs fails so
    #the directory doesn't exist.  So for the time being, if makedirs fails, we re-invoke the function once.
    #TODO: Figure out race condition.
    try:
        shutil.rmtree(outputdir)
    except WindowsError:
        pass
    if os.path.exists(outputdir):
        raise IOError, '%s was not deleted.' % outputdir
    try:
        os.makedirs(outputdir)
    except WindowsError:
        if not _ran:
            ensure_clean_output(outputdir, _ran=True)
        if not os.path.isdir(outputdir):
            raise

def _create_dependency_group(codefilenames, dependencygroup):
    """If dependencygroup is provided, returns that, otherwise generates a new DependencyGroup from
    codefilenames.
    """
    if not dependencygroup:
        depb = depgraph.DepBuilder(codefilenames)
        dependencygroup = depgraph.DependencyGroup(depb.dependencies, depb.failed)
    return dependencygroup

def _generate_html_jump_str(htmlfilename, paths):
    """Generates the html contents for the jump page."""
    htmltemplate = '\n'.join(
        ['<html>',
        '  <head>',
        '    <title>Project Metrics, generated by pynocle.</title>',
        '  </head>',
        '  <body>',
        '%s',
        '  </body>',
        '</html>'])
    row = '      <a href="{0}">{0}</a>'
    absdir = os.path.dirname(os.path.abspath(htmlfilename)) + os.sep
    def hrefpath(p):
        absp = os.path.abspath(p)
        relp = absp.replace(absdir, '')
        return relp
    lines = [row.format(hrefpath(p)) for p in paths]
    return htmltemplate % '\n      <br />\n'.join(lines)

def generate_html_jump(filename, *paths):
    """Generates an html file at filename that contains links to all items in paths.

    filename: Filename of the resultant file.
    paths: Paths to all files the resultant file should display links to.
    """
    with open(filename, 'w') as f:
        f.write(_generate_html_jump_str(filename, sorted(paths)))

class Monocle(object):
    """Class that manages the filenames and default paths for the monocle methods.  Methods are the same as
    top-level module functions.

    outputdir: Directory to write reports.
    rootdir: The root directory of the python files to search.
    coveragedata: A coverage.coverage instance.  You can get this from running coverage, or loading a coverage data
        file.
    debug: If True, fail early instead of failing after all report generation.

    Other arguments are filenames relative to outputdir that reports will be written to,
    and factory methods that are used to output those reports.
    """
    def __init__(self, outputdir='output',
                 rootdir=None,
                 coveragedata=None,
                 coverhtml_dir='report_covhtml',
                 coverreport_filename='report_coverage.txt',
                 cyclcompl_filename='report_cyclcompl.html',
                 sloc_filename='report_sloc.html',
                 depgraph_filename='depgraph.png',
                 coupling_filename='report_coupling.html',
                 couplingrank_filename='report_couplingrank.html',
                 htmljump_filename='index.html',
                 debug=False):
        if not isinstance(rootdir, basestring):
            raise ValueError, 'Monocle only supports one root directory right now.'
        rootdir = os.path.abspath(rootdir or os.getcwd())
        self.filenames = utils.find_all([rootdir])

        self.outputdir = outputdir
        self.coveragedata = coveragedata
        self.debug = debug

        join = lambda x: os.path.join(self.outputdir, x)
        self.coverhtml_dir = join(coverhtml_dir)
        self.coverreport_filename = join(coverreport_filename)
        self.cyclcompl_filename = join(cyclcompl_filename)
        self.sloc_filename = join(sloc_filename)
        self.depgraph_filename = join(depgraph_filename)
        self.coupling_filename = join(coupling_filename)
        self.couplingrank_filename = join(couplingrank_filename)
        self.htmljump_filename = join(htmljump_filename)

        kwargs = {'leading_path': rootdir}
        def gext(s):
            return os.path.splitext(s)[1]
        self.cyclcompl_fmtfactory = cyclcompl.formatter_registry.GetFormatterFactory(gext(self.cyclcompl_filename),
                                                                                     **kwargs)
        self.sloc_fmtfactory = sloc.formatter_registry.GetFormatterFactory(gext(self.sloc_filename), **kwargs)
        self.coupling_fmtfactory = depgraph.coupling_formatter_registry.GetFormatterFactory(
            gext(self.coupling_filename), **kwargs)
        self.couplingrank_fmtfactory = depgraph.couplingrank_formatter_registry.GetFormatterFactory(
            gext(self.couplingrank_filename), **kwargs)

        self.depgraph_renderfactory = lambda g: depgraph.DefaultRenderer(g, leading_path=rootdir)
        
        self._filesforjump = set()

    def ensure_clean_output(self):
        ensure_clean_output(self.outputdir)

    def generate_cover_html(self):
        """Outputs a coverage html report from cov into directory.

        cov: An instance of coverage.coverage.
        directory: The directory all the html files will be output to.  Directory must exist.
        """
        #isinstance causes scope problems so use exact type checking here.
        _check_coverage()
        self.coveragedata.html_report(directory=self.coverhtml_dir)
        self._filesforjump.add(os.path.join(self.coverhtml_dir, 'index.html'))

    def generate_cover_report(self):
        """Generates a coverage report for cov to filename."""
        #isinstance causes scope problems so use exact type checking here.
        _check_coverage()
        with open(self.coverreport_filename, 'w') as f:
            self.coveragedata.report(file=f)
        self._filesforjump.add(self.coverreport_filename)

    def generate_cyclomatic_complexity(self):
        """Generates a cyclomatic complexity report based on all the files in codefilenames, output to reportfilename.
        """
        ccdata, failures = cyclcompl.measure_cyclcompl(self.filenames)
        utils.write_report(self.cyclcompl_filename, (ccdata, failures), self.cyclcompl_fmtfactory)
        self._filesforjump.add(self.cyclcompl_filename)

    def generate_sloc(self):
        """Generates a Source Lines of Code report for files in codefilenames, output to reportfilename.

        formatter_factory: Callable that takes the filestream of reportfilename returns the sloc.ISlocFormatter to use
            to format the report.
        """
        slocgrp = sloc.SlocGroup(self.filenames)
        utils.write_report(self.sloc_filename, slocgrp, self.sloc_fmtfactory)
        self._filesforjump.add(self.sloc_filename)

    def generate_dependency_graph(self, _depgrp=None):
        """Generates a dependency graph image to reportfilename for the files in codefilenames.  Returns an
        instance of dependency_group.
        """
        depgrp = _create_dependency_group(self.filenames, _depgrp)
        renderer = self.depgraph_renderfactory(depgrp)
        renderer.render(self.depgraph_filename)
        self._filesforjump.add(self.depgraph_filename)
        return depgrp

    def generate_coupling_report(self, _depgrp=None):
        """Generates a report for Afferent and Efferent Coupling between all modules in codefilenames, saved to
        reportfilename.  Returns an instance of DependencyGroup.
        """
        depgrp = _create_dependency_group(self.filenames, _depgrp)
        utils.write_report(self.coupling_filename, depgrp, self.coupling_fmtfactory)
        self._filesforjump.add(self.coupling_filename)
        return depgrp

    def generate_couplingrank_report(self, _depgrp=None):
        """Generates a PageRank report for all modules in codefilenames, saved to reportfilename.

        formatter_factory: Callable that returns an ICouplingFormatter instance.
        """
        depgrp = _create_dependency_group(self.filenames, _depgrp)
        utils.write_report(self.couplingrank_filename, depgrp, self.couplingrank_fmtfactory)
        self._filesforjump.add(self.couplingrank_filename)
        return depgrp

    def generate_html_jump(self):
        """Generates an html page that links to any generated reports."""
        return generate_html_jump(self.htmljump_filename, *sorted(self._filesforjump))

    def generate_all(self, cleanoutput=True):
        """Run all report generation functions.

        If coveragedata is not set, skip the coverage functions.
        Raises an AggregateError after all functions run if any function raises.
        cleanoutput: If True, run ensure_clean_output to clear the output directory.
        """
        if cleanoutput:
            self.ensure_clean_output()
        excs = []
        def trydo(func):
            if self.debug:
                return func()
            try:
                return func()
            except Exception as exc:
                import traceback
                excs.append((exc, traceback.format_exc()))

        trydo(self.generate_sloc)
        trydo(self.generate_cyclomatic_complexity)

        if self.coveragedata:
            trydo(self.generate_cover_report)
            trydo(self.generate_cover_html)
            
        depgrp = trydo(self.generate_coupling_report)
        depgrp = trydo(lambda: self.generate_couplingrank_report(depgrp))
        depgrp = trydo(lambda: self.generate_dependency_graph(depgrp))
        trydo(self.generate_html_jump)
         #self.generate_funcinfo_report,
         #self.generate_inheritance_report,
        if excs:
            raise utils.AggregateError, excs
